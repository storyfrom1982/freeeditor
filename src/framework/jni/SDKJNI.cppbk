//
// Created by yongge on 19-5-20.
//

#include "SDKJNI.hbk"
#include <android/log.h>

#include <MConfig.h>
#include <EnvContext.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <sr_malloc.h>
#include <sr_library.h>

#ifdef __cplusplus
}
#endif


using namespace freee;


JavaVM *global_JVM_Instance;


static void log_debug(int level, const char *debug_log, const char *pure_log)
{
    static const char *tag = "FREEESDK";
    if (level == SR_LOG_LEVEL_DEBUG){
        __android_log_print(ANDROID_LOG_DEBUG, tag, "%s", pure_log);
    }else if (level == SR_LOG_LEVEL_INFO){
        __android_log_print(ANDROID_LOG_INFO, tag, "%s", pure_log);
    }else if (level == SR_LOG_LEVEL_WARN){
        __android_log_print(ANDROID_LOG_WARN, tag, "%s", pure_log);
    }else if (level == SR_LOG_LEVEL_ERROR){
        __android_log_print(ANDROID_LOG_ERROR, tag, "%s", pure_log);
    }
}



class MsgHandler : public StreamProcessor {

public:

    MsgHandler(jobject obj){
        JniEnv env;
        m_obj = env->NewGlobalRef(obj);
        m_class = env->GetObjectClass(m_obj);
        m_onReceiveMessage = env->GetMethodID(m_class, "onReceiveMessage", "(Lcn/freeeditor/sdk/Msg;)V");
        m_onReceiveRequest = env->GetMethodID(m_class, "onReceiveRequest", "(Lcn/freeeditor/sdk/Msg;)Lcn/freeeditor/sdk/Msg;");

        m_msgClass = static_cast<jclass>(env->NewGlobalRef(env->FindClass("cn/freeeditor/sdk/Msg")));
        m_buildInteger = env->GetMethodID(m_msgClass, "<init>", "(IJ)V");
        m_buildFloat = env->GetMethodID(m_msgClass, "<init>", "(ID)V");
        m_buildObject = env->GetMethodID(m_msgClass, "<init>", "(ILjava/lang/Object;)V");
        m_buildString = env->GetMethodID(m_msgClass, "<init>", "(ILjava/lang/String;)V");

        m_keyField = env->GetFieldID(m_msgClass, "key", "I");
        m_typeField = env->GetFieldID(m_msgClass, "type", "I");
        m_int64Field = env->GetFieldID(m_msgClass, "i64", "J");
        m_float64Field = env->GetFieldID(m_msgClass, "f64", "D");
        m_objField = env->GetFieldID(m_msgClass, "obj", "Ljava/lang/Object;");
    };

    ~MsgHandler(){
        JniEnv env;
        if (m_obj != NULL){
            env->DeleteGlobalRef(m_obj);
        }
        if (m_msgClass != NULL){
            env->DeleteGlobalRef(m_msgClass);
        }
    };

    jobject msg2obj(JNIEnv *env, sr_msg_t msg){
        jobject obj;
        if (__sr_msg_is_float(msg)){
            obj = env->NewObject(m_msgClass, m_buildFloat, msg.key, msg.f64);
        }else if (__sr_msg_is_pointer(msg)){
            obj = env->NewObject(m_msgClass, m_buildObject, msg.key, (jobject)msg.p64);
        }else if (__sr_msg_is_string(msg)){
            jstring s = env->NewStringUTF(static_cast<const char *>(msg.p64));
            obj = env->NewObject(m_msgClass, m_buildString, msg.key, s);
            env->DeleteLocalRef(s);
            __sr_msg_clear(msg);
        }else {
            obj = env->NewObject(m_msgClass, m_buildInteger, msg.key, msg.i64);
        }
        return obj;
    }

    sr_msg_t obj2msg(JNIEnv *env, jobject obj){
        sr_msg_t msg;
        msg.key = env->GetIntField(obj, m_keyField);
        msg.type = env->GetIntField(obj, m_typeField);
        if (__sr_msg_is_integer(msg)){
            msg.i64 = env->GetLongField(obj, m_int64Field);
        }else if (__sr_msg_is_float(msg)){
            msg.f64 = env->GetDoubleField(obj, m_float64Field);
        }else if (__sr_msg_is_pointer(msg)){
            msg.p64 = env->GetObjectField(obj, m_objField);
        }else if (__sr_msg_is_string(msg)){
            jstring js = (jstring)env->GetObjectField(obj, m_objField);
            const char *s = env->GetStringUTFChars(js, 0);
            msg.size = (size_t)env->GetStringUTFLength(js);
            msg.p64 = strdup(s);
            env->ReleaseStringUTFChars(js, s);
            env->DeleteLocalRef(js);
        }
        return msg;
    }

    void sendJniMessageToOutputStream(JNIEnv *env, jobject obj){
        sr_msg_t msg = obj2msg(env, obj);
        sendMessageToOutputStream(msg);
    }

    jobject sendJniRequestToOutputStream(JNIEnv *env, jobject obj){
        sr_msg_t msg = obj2msg(env, obj);
        msg = sendRequestToOutputStream(msg, 0);
        return msg2obj(env, msg);
    }

protected:

    void messageFromOutputStream(sr_msg_t msg) override {
        JniEnv env;
        jobject obj = msg2obj(env.m_pEnv, msg);
        env->CallVoidMethod(m_obj, m_onReceiveMessage, obj);
        env->DeleteLocalRef(obj);
    }

    sr_msg_t requestFromOutputStream(sr_msg_t msg) override {
        JniEnv env;
        jobject obj = msg2obj(env.m_pEnv, msg);
        jobject Msg = env->CallObjectMethod(m_obj, m_onReceiveRequest, obj);
        env->DeleteLocalRef(obj);
        return obj2msg(env.m_pEnv, Msg);
    }

private:

    jobject m_obj;
    jclass m_class;
    jmethodID m_onReceiveMessage;
    jmethodID m_onReceiveRequest;

    jclass m_msgClass;
    jmethodID m_buildInteger;
    jmethodID m_buildFloat;
    jmethodID m_buildObject;
    jmethodID m_buildString;

    jfieldID m_keyField;
    jfieldID m_typeField;
    jfieldID m_int64Field;
    jfieldID m_float64Field;
    jfieldID m_objField;
};


JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM* vm, void* reserved) {
    global_JVM_Instance = vm;
    sr_setup_crash_backtrace();
    sr_log_set_callback(SR_LOG_LEVEL_DEBUG, log_debug);
    return JNI_VERSION_1_6;
}

extern "C"
JNIEXPORT jlong JNICALL
Java_cn_freeeditor_sdk_MsgHandler_build(JNIEnv *env, jobject instance) {
    MsgHandler *msgHandler = new MsgHandler(instance);
    return (jlong)(msgHandler);
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_MsgHandler_remove(JNIEnv *env, jobject instance, jlong handlerInstance) {
    if (handlerInstance != 0){
        MsgHandler *msgHandler = (MsgHandler *)handlerInstance;
        delete msgHandler;
    }
}

extern "C"
JNIEXPORT jobject JNICALL
Java_cn_freeeditor_sdk_MsgHandler_sendRequest(JNIEnv *env, jobject instance, jobject msg, jlong handlerInstance) {
    if (handlerInstance == 0){
        jclass msgClass = static_cast<jclass>(env->NewGlobalRef(env->FindClass("cn/freeeditor/sdk/Msg")));
        jmethodID buildMsg = env->GetMethodID(msgClass, "<init>", "(IJ)V");
        return env->NewObject(msgClass, buildMsg, -1, -1);
    }
    MsgHandler *msgHandler = (MsgHandler *)handlerInstance;
    return msgHandler->sendJniRequestToOutputStream(env, msg);
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_MsgHandler_sendMessage(JNIEnv *env, jobject instance, jobject msg, jlong handlerInstance) {
    if (handlerInstance != 0){
        MsgHandler *msgHandler = (MsgHandler *)handlerInstance;
        msgHandler->sendJniMessageToOutputStream(env, msg);
    }
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_MsgHandler_setListener(JNIEnv *env, jobject instance, jlong processorInstance, jlong handlerInstance) {
    StreamProcessor *msgHandler = (StreamProcessor *)handlerInstance;
    StreamProcessor *msgProcessor = (StreamProcessor *)processorInstance;
    if (msgHandler && msgProcessor){
        msgHandler->addOutputStream(msgProcessor);
    }
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_MContext_apply(JNIEnv *env, jobject instance, jlong handlerInstance) {
    if (handlerInstance != 0){
        MsgHandler *msgHandler = (MsgHandler *)handlerInstance;
        EnvContext::Instance()->addInputStream(msgHandler);
    }
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_MContext_remove(JNIEnv *env, jobject instance, jlong handlerInstance) {
    if (handlerInstance != 0){
        MsgHandler *msgHandler = (MsgHandler *)handlerInstance;
        msgHandler->removeOutputStream(EnvContext::Instance());
        EnvContext::Instance()->removeInputStream(msgHandler);
        delete EnvContext::Instance();
    }
    sr_log_file_close();
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_MContext_debug(JNIEnv *env, jobject instance) {
    sr_malloc_debug(sr_log_msg);
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_Log_d(JNIEnv *env, jclass type, jstring tag_, jstring msg_) {
    const char *tag = env->GetStringUTFChars(tag_, 0);
    const char *msg = env->GetStringUTFChars(msg_, 0);
    sr_log_debug(SR_LOG_LEVEL_DEBUG, tag, "Java", 0, "%s\n", msg);
    env->ReleaseStringUTFChars(tag_, tag);
    env->ReleaseStringUTFChars(msg_, msg);
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_sdk_Log_e(JNIEnv *env, jclass type, jstring tag_, jstring msg_) {
    const char *tag = env->GetStringUTFChars(tag_, 0);
    const char *msg = env->GetStringUTFChars(msg_, 0);
    sr_log_debug(SR_LOG_LEVEL_ERROR, tag, "Java", 0, "%s\n", msg);
    env->ReleaseStringUTFChars(tag_, tag);
    env->ReleaseStringUTFChars(msg_, msg);
}


#ifdef __cplusplus
extern "C" {
#endif

#include <GLRenderer.h>

#ifdef __cplusplus
}
#endif


#include <android/native_window.h>
#include <android/native_window_jni.h>


#include <GLES/gl.h>
#include <GLES3/gl3.h>
#include <GLES3/gl3ext.h>

#define NK_SHADER_VERSION "#version 100\n"

static const GLchar *vertexShaderSource =
        NK_SHADER_VERSION
        "attribute vec3 Position;\n"
        "void main() {\n"
        "   gl_Position = vec4(Position.x, Position.y, Position.z, 1.0);\n"
        "}\n";

static const GLchar *fragmentShaderSource =
        NK_SHADER_VERSION
        "precision mediump float;\n"
        "varying vec4 Frag_Color;\n"
        "void main(){\n"
        "   gl_FragColor = vec4(1.0, 0.5, 0.2, 1.0);\n"
        "}\n";


gl_window_t *window;
gl_renderer_t *renderer;





extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_android_PlayerActivity_createRenderer(JNIEnv *env, jobject instance,
                                                         jobject surface) {

    window = gl_window_create(env, surface);

    renderer = gl_renderer_create(gl_window_get_window_width(window), gl_window_get_window_height(window));

    gl_renderer_set_window(renderer, window);

    int width = gl_window_get_window_width(window);
    int height = gl_window_get_window_height(window);



    // build and compile our shader program
    // ------------------------------------
    // vertex shader
    int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    // check for shader compile errors
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        LOGE("ERROR::SHADER::VERTEX::COMPILATION_FAILED: %s\n", infoLog);
    }
    // fragment shader
    int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
    // check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
    if (!success)
    {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        LOGE("ERROR::SHADER::FRAGMENT::COMPILATION_FAILED: %s\n", infoLog);
    }
    // link shaders
    int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        LOGE("ERROR::SHADER::PROGRAM::LINKING_FAILED: %s\n", infoLog);
    }
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
            0.5f,  0.5f, 0.0f,  // top right
            0.5f, -0.5f, 0.0f,  // bottom right
            -0.5f, -0.5f, 0.0f,  // bottom left
            -0.5f,  0.5f, 0.0f   // top left
    };
    unsigned int indices[] = {  // note that we start from 0!
            0, 1, 3,  // first Triangle
            1, 2, 3   // second Triangle
    };
    unsigned int VBO, VAO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // remember: do NOT unbind the EBO while a VAO is active as the bound element buffer object IS stored in the VAO; keep the EBO bound.
    //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    // You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
    // VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
    glBindVertexArray(0);

    glViewport(0, 0, width, height);

    // render
    // ------
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // draw our first triangle
    glUseProgram(shaderProgram);
    glBindVertexArray(VAO); // seeing as we only have a single VAO there's no need to bind it every time, but we'll do so to keep things a bit more organized
    //glDrawArrays(GL_TRIANGLES, 0, 6);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    gl_renderer_swap_buffers(renderer);

    // optional: de-allocate all resources once they've outlived their purpose:
    // ------------------------------------------------------------------------
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteBuffers(1, &EBO);
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_android_PlayerActivity_releaseRenderer(JNIEnv *env, jobject instance) {

    gl_renderer_release(&renderer);
    gl_window_release(&window);
}

extern "C"
JNIEXPORT void JNICALL
Java_cn_freeeditor_android_PlayerActivity_rendererDraw(JNIEnv *env, jobject instance) {

}